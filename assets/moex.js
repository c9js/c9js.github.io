/*────────────────────────────────────────────────────────────────────────────────────────────────*/
/*┌────────────────────────────────────────────────────────────┐
  │ Будет сделан только первый запрос, далее данные кешируются │
  └────────────────────────────────────────────────────────────┘
// Пример 1
    MOEX.addTickers(['LKOH', 'SBER'])
    .then(alert);
    
// Пример 2
    MOEX.addTickers('LKOH', 'SBER')
    .then(alert);
    
// Пример 3
    MOEX.addTickers(['PHOR', 'IRAO', 'GCHE']);
    MOEX.then(alert);
    
// Пример 4
    MOEX.addTickers('PHOR', 'IRAO', 'GCHE');
    MOEX.then(alert);
    
// Пример 5
    MOEX.addTickers('PHOR');
    MOEX.addTickers('IRAO');
    MOEX.addTickers('GCHE');
    MOEX.then(alert);
    
*┌─────────────────────────────────────────────────────┐
 │ Каждый раз будет новый запрос, данные не кешируются │
 └─────────────────────────────────────────────────────┘
    MOEX.load(['LKOH', 'SBER']).then(alert);
    MOEX.load('LKOH', 'SBER').then(alert);
    
/*────────────────────────────────────────────────────────────────────────────────────────────────*/

class MOEX {
// Адрес API биржи
    static url = [
        'https://iss.moex.com/iss/engines/stock/markets/shares/boards/TQBR/securities/',
        '.json?iss.meta=off'
    ];
    
// Тикер по умолчанию
    static defaultTicker = 'AAAA';
    
// Валютный тикер
    static currency = 'RUBB';
    
// Список тикеров с минимально возможным количеством для совершения покупки
    static minBuy = {
        'SBER': 10,
        'MOEX': 10,
        'MTSS': 10,
        'IRAO': 100
    };
    
// Список необработанных тикеров
    static tickers = {};
    
// Кеш-список со стоимостью тикеров
    static prices = {};
    
/*┌─────────────────────────────┐
  │ Возвращает стоимость тикера │
  └─────────────────────────────┘*/
    static price(ticker = '') {
        return Number(this.prices[ticker] || 0);
    }
    
/*┌──────────────────────────────────────────────────────┐
  │ Возвращает текущее количество необработанных тикеров │
  └──────────────────────────────────────────────────────┘*/
    static get loadCount() {
        return Object.keys(this.tickers).length;
    }
    
/*┌───────────────────────────────────────────────────────────┐
  │ Добавляет список тикеров в очередь на получение стоимости │
  └───────────────────────────────────────────────────────────┘*/
    static addTickers(...tickers) {
    // Проходим по списку тикеров
        tickers.flat(Infinity).forEach((ticker) => {
        // Проверяем наличие стоимости для текущего тикера
            if (!(ticker in this.prices)) {
            // Присваиваем нулевую стоимость
                this.prices[ticker] = 0;
                
            // Добавляем тикер в очередь
                this.tickers[ticker] = ticker;
            }
        });
        
    // Отправляем список необработанных тикеров на получение стоимости
        return this._loader;
    }
    
/*┌─────────────────────────────────────┐
  │ Возвращает порядковый номер столбца │
  └─────────────────────────────────────┘*/
    static getCol(columns = [], col = '') {
    // Проходим по списку столбцов
        for (let i = 0; i < columns.length; i++) {
        // Проверяем текущий столбец
            if (col == columns[i]) return i;
        }
    }
    
/*┌───────────────────────────────────────┐
  │ Получает список со стоимостью тикеров │
  └───────────────────────────────────────┘*/
    static getPrice(field = '', tickers = [], res = {}) {
    // Получаем порядковый номер столбца текущего тикера
        const SECID = this.getCol(res.columns, 'SECID');
        
    // Получаем порядковый номер столбца со стоимостью тикера
        const PRICE = this.getCol(res.columns, field);
        
    // Создаем список со стоимостью тикеров
        let prices = {};
        
    // Проходим по списку со стоимостью
        res.data.forEach((fields, i) => {
        // Проходим по списку тикеров
            tickers.forEach((ticker) => {
            // Проверяем текущий тикер
                if (fields[SECID] == ticker) {
                // Получаем стоимость тикера
                    let price = Number(fields[PRICE] || 0);
                    
                // Проверяем текущую стоимость
                    if (price > 0) {
                    // Добавляем стоимость в список
                        prices[ticker] = Number(fields[PRICE]);
                    }
                }
            });
        });
        
    // Возвращаем список со стоимостью тикеров
        return prices;
    }
    
/*┌───────────────────────────────────────┐
  │ Получает список со стоимостью тикеров │
  └───────────────────────────────────────┘*/
    static getPrices(tickers = [], res = {}) {
    // Создаем списки со стоимостью последних сделок
        let last = {}; // Текущий торговый день
        let prev = {}; // Предыдущий торговый день
        
    // Получаем список со стоимостью последних сделок текущего торгового дня
        last = this.getPrice('LAST', tickers, res.marketdata);
        
    // Список не найден или не полный
        if (tickers.length != Object.keys(last).length) {
        // Получаем список со стоимостью последних сделок предыдущего торгового дня
            prev = this.getPrice('PREVPRICE', tickers, res.securities);
        }
        
    // Создаем список со стоимостью тикеров
        let prices = {};
        
    // Проходим по списку тикеров
        tickers.forEach((ticker) => {
        // Добавляем стоимость в список
            prices[ticker] = Number(
                last[ticker] || prev[ticker] || 0
            );
            
        // Добавляем стоимость в кеш-список
            this.prices[ticker] = prices[ticker];
        });
        
    // Возвращаем список со стоимостью тикеров
        return prices;
    }
    
/*┌────────────────────────────┐
  │ Получает данные по тикерам │
  └────────────────────────────┘*/
    static async request(tickers = []) {
        let ticker = tickers.length == 1 ? tickers[0] : '';
        return await fetch(this.url.join(ticker)).then(res => res.json());
    }
    
/*┌─────────────────────────────────────────────────────────────────┐
  │ Отправляет список необработанных тикеров на получение стоимости │
  └─────────────────────────────────────────────────────────────────┘*/
    static async load(...tickers) {
    // Откладываем выполнение
        await Promise.resolve();
        
    // Получаем список тикеров (без повторений)
        tickers = [...new Set(tickers.flat(Infinity))];
        
    // Проверяем список тикеров
        if (tickers.length == 0) return;
        
    // Возвращаем список со стоимостью тикеров
        return this.getPrices(tickers, (await this.request(tickers)));
    }
    
/*┌─────────────────────────────────────────────────────────────────┐
  │ Отправляет список необработанных тикеров на получение стоимости │
  └─────────────────────────────────────────────────────────────────┘*/
    static async loader() {
    // Откладываем выполнение
        await Promise.resolve();
        
    // Искуственная задержка для отладки
        // await new Promise(r => setTimeout(r, 3000))
        
    // Получаем список тикеров
        let tickers = Object.keys(this.tickers);
        
    // Проверяем список тикеров
        if (tickers.length == 0) return this.prices;
        
    // Получаем список со стоимостью тикеров
        this.getPrices(tickers, (await this.request(tickers)));
        
    // Добавляем стоимость для тикера по умолчанию
        this.prices[this.defaultTicker] = 0;
        
    // Добавляем стоимость для валютного тикера
        this.prices[this.currency] = 1;
        
    // Обнуляем очередь
        this.tickers = {};
        
    // Проверяем обработчик для полной загрузки стоимости тикеров
        if (typeof this.onload == 'function') {
        // Выполняем обработчик для полной загрузки стоимости тикеров
            this.onload(this.prices);
        }
        
    // Возвращаем список со стоимостью тикеров
        return this.prices;
    }
    
/*┌─────────────────────────────────────────────────────────┐
  │ Добавляет колбэк который будет выполнен в случае успеха │
  └─────────────────────────────────────────────────────────┘*/
    static then(callback) {
        return this._loader.then(callback);
    }
    
/*┌───────────────────────────────────────────────────────────┐
  │ Добавляет колбэк который будет выполнен в случае не удачи │
  └───────────────────────────────────────────────────────────┘*/
    static catch(callback) { 
        return this._loader.catch(callback);
    }
    
/*┌───────────────────────────┐
  │ Возвращает текущий промис │
  └───────────────────────────┘*/
    static get _loader() {
    // Проверяем текущий промис
        if (!this._promise) {
        // Отправляем список необработанных тикеров на получение стоимости
            this._promise = this.loader().finally(r => this._promise = 0);
        }
        
    // Возвращаем текущий промис
        return this._promise;
    }
    
/*┌───────────────────────────────────────────────────────────────────┐
  │ Возвращает минимально возможное количество для совершения покупки │
  └───────────────────────────────────────────────────────────────────┘*/
    static minCount(ticker = '') {
        return this.minBuy[ticker] || 1;
    }
    
/*┌──────────────────────────────────────────────┐
  │ Проверяет является-ли тикер валютным тикером │
  └──────────────────────────────────────────────┘*/
    static isCurrency(ticker = '') {
        return ticker == this.currency;
    }
    
/*┌─────────────────────────────────┐
  │ Создает предложение для покупки │
  └─────────────────────────────────┘*/
    static offer(tickers = [], costs = [], prices = [], offers = [], currency = -1) {
    // Проходим по списку предложений
        while (true) {
        // Валютный тикер не найден
            if (currency == -1) break;
            
        // Создаем номер тикера с наименьшей общей стоимостью
            let ticker = -1;
            
        // Проходим по списку тикеров с текущей стоимостью
            costs.reduce((min, cost, i) => {
            // Проверяем является-ли тикер валютным тикером
                if (currency == i) return min;
                
            // Стоимость тикера меньше одного
                if (prices[i] < 1) return min;
                
            // Стоимость тикера больше текущего баланса
                if (prices[i] > costs[currency]) return min;
                
            // Тикер не является тикером с наименьшей общей стоимостью
                if (cost > min) return min;
                
            // Получаем номер тикера с наименьшей общей стоимостью
                ticker = i;
                
            // Возвращаем наименьшую общую стоимость
                return cost;
            }, Infinity);
            
        // На текущем балансе недостаточно средств
            if (ticker == -1) break;
            
        // На текущем балансе недостаточно средств
            if (prices[ticker] > costs[currency]) break;
            
        // Прибавляем текущую стоимость к общей стоимости
            costs[ticker] += prices[ticker];
            
        // Прибавляем текущую стоимость к общей стоимости
            offers[ticker] += this.minCount(tickers[ticker]);
            
        // Вычитаем текущую стоимость из баланса
            costs[currency] -= prices[ticker];
        }
        
    // Переводим в строку
        costs = costs.map(cost => String(cost));
        
    // Переводим в строку и добавляем плюс
        offers = offers.map(offer => offer > 0 ? ['+', offer].join('') : '');
        
    // Возвращаем предложение для покупки
        return {
            costs: costs,   // Столбец с текущей стоимостью
            offers: offers, // Столбец с дополнительным количеством
        };
    }
    
/*┌─────────────────────────────────┐
  │ Создает ребалансировку портфеля │
  └─────────────────────────────────┘*/
    static rebalance(tickers = [], counts = []) {
    // Создаем список с текущей стоимостью
        let costs = tickers.map((ticker, i) => {
            return parseInt(this.price(ticker) * counts[i]||0);
        });
        
    // Создаем список с минимально возможной стоимостью
        let prices = tickers.map((ticker, i) => {
            return parseInt(this.price(ticker) * this.minCount(ticker));
        });
        
    // Создаем список с дополнительным количеством
        let offers = Array(counts.length).fill(0);
        
    // Создаем номер валютного тикера
        let currency = tickers.findIndex(ticker => this.isCurrency(ticker));
        
    // Создаем предложение для покупки
        return this.offer(tickers, costs, prices, offers, currency);
    }
}

/*────────────────────────────────────────────────────────────────────────────────────────────────*/