/*────────────────────────────────────────────────────────────────────────────────────────────────*/

Object.defineProperties(global,{__:{set:v=>process.exit(_=v)},_:{set:console.log}});

/*────────────────────────────────────────────────────────────────────────────────────────────────*/

class Table {
/*┌───────────────────────┐
  │ Создает новую таблицу │
  └───────────────────────┘*/
    constructor(...args) {
    // Создаем список пределов таблицы
        this.limits = [];
        
    // Создаем список аргументов по типу
        let types = {
            'string': v => this.value = v,           // Содержимое таблицы
            'number': v => this.limits.push(v),      // Номер столбца
            'boolean': v => this.isSaveEmptyRows = v // Флаг сохранять пустые ряды
        };
        
    // Проходим по списку аргументов
        args.forEach(arg => types[typeof arg](arg));
    }
    
/*┌───────────────────────────────┐
  │ Возвращает содержимое таблицы │
  └───────────────────────────────┘*/
    get value() {
    // Проверяем текущее содержимое таблицы
        if (this.content === void 0) {
        // Обновляем текущую таблицу
            this.update();
        }
        
    // Возвращаем содержимое таблицы
        return this.content;
    }
    
/*┌────────────────────────────┐
  │ Создает содержимое таблицы │
  └────────────────────────────┘*/
    set value(content = '') {
    // Обнуляем содержимое таблицы
        delete this.content;
        
    // Переводим строку в массив
        content = String(content).split('\n');
        
    // Создаем список рядов
        this.rows = content.map(line => line.split(/\s+/).filter(v => v !== ''));
        
    // Удаляем пустые ряды
        let rows = this.rows.filter(row => row.length);
        
    // Проверяем список пределов таблицы
        if (this.limits.length > 0) {
        // Удаляем столбцы вне списка пределов таблицы
            rows = rows.map(row => row.filter((col, i) => {
                return this.range(this.limits).includes(i);
            }));
        }
        
    // Получаем максимальное количество столбцов
        let length = rows.reduce((length, row) => {
            return length < row.length ? row.length : length;
        }, 0);
        
    // Создаем список столбцов
        this.cols = Array(length).fill().map(col => []);
        
    // Проходим по списку рядов
        rows.forEach((row) => {
        // Проходим по списку столбцов
            this.cols.forEach((col, i) => {
            // Создаем новый столбец
                col.push(row[i]||'');
            });
        });
    }
    
/*┌───────────────────────────┐
  │ Обновляет текущую таблицу │
  └───────────────────────────┘*/
    update() {
    // Выравниваем столбцы по правому краю (отступы слева)
        this.cols = this.cols.map((col) => {
            return this.toPads(col, 'right');
        });
        
    // Создаем порядковый номер
        let i = -1;
        
    // Удаляем пустые ряды
        if (!this.isSaveEmptyRows) {
        // Проходим по структуре столбцов (столбцы из первого ряда)
            this.content = this.col(0).map((cell, i) => {
                return this.cols.map(col => col[i]).join(' ');
            }).join('\n');
        }
        
    // Сохраняем пустые ряды
        else {
        // Проходим по списку рядов
            this.content = this.rows.map((row) => {
            // Увеличиваем порядковый номер
                i += row.length ? 1 : 0;
                
            // Возвращаем результат
                return !row.length ? '' : this.cols.map(col => col[i]).join(' ');
            }).join('\n');
        }
    }
    
/*┌───────────────────────────────────┐
  │ Создает диапазон номеров столбцов │
  └───────────────────────────────────┘*/
    range(cols = []) {
    // Передано количество столбцов (от 0 до cols[0])
        if (cols.length == 1 && cols[0] < 0) {
            return Array(~cols[0]).fill().map((c, i) => i);
        }
        
    // Передан диапазон столбцов (от cols[0] до cols[1])
        else if (cols.length == 2 && cols[0] < 0 && cols[1] < 0) {
            return Array(~cols[1] - ~cols[0] + 1).fill().map((c, i) => i + ~cols[0] - 1);
        }
        
    // Переданы конкретные номера столбцов
        else {
            return cols.map(v => v - 1);
        }
    }
    
/*┌───────────────────────────────────────────────────┐
  │ Прерывает дальнейшее внесение изменений в таблицу │
  └───────────────────────────────────────────────────┘*/
    get break() {
        this.isBreak = true;
    }
    
/*┌───────────────────────────────┐
  │ Добавляет изменения в таблицу │
  └───────────────────────────────┘*/
    edit(...args) {
    // Проверяем брэк
        if (this.isBreak) return this;
        
    // Создаем колбэк
        let callback;
        
    // Создаем список столбцов
        let cols = [];
        
    // Создаем список аргументов по типу
        let types = {
            'number': v => cols.push(v),  // Количество столбцов
            'function': v => callback = v // Колбэк
        };
        
    // Проходим по списку аргументов
        args.forEach(arg => types[typeof arg](arg));
        
    // Проверяем колбэк
        if (typeof callback == 'function') {
        // Выполняем колбэк (добавляем изменения в таблицу)
            callback.apply(this, this.range(cols));
        }
        
    // Возвращаем текущее окружение
        return this;
    }
    
/*┌────────────────────────────────────────┐
  │ Выравнивает по левому или правому краю │
  └────────────────────────────────────────┘*/
    toPads(list = [], course = 'right') {
    // Переводим в строку
        list = list.map(value => String(value));
        
    // Получаем максимальную длину
        let length = list.reduce((length, value) => {
            return length < value.length ? value.length : length;
        }, 0);
        
    // Возвращаем результат
        return list.map((value) => {
        // Выравниваем по левому краю (отступы справа)
            if (course == 'left') {
                return [value, Array(length+1).join(' ')].join('').substring(0, length);
            }
            
        // Выравниваем по правому краю (отступы слева)
            return [Array(length+1).join(' '), value].join('').slice(length*-1);
        });
    }
    
/*┌───────────────────────────────────────────┐
  │ Удадяет текущий столбец из списка столбцов│
  └───────────────────────────────────────────┘*/
    delete(target = 0) {
    // Обнуляем содержимое таблицы
        delete this.content;
        
    // Удадяем текущий столбец
        delete this.cols[target];
    }
    
/*┌─────────────────────────────────────────────┐
  │ Обновляет текущий столбец в списке столбцов │
  └─────────────────────────────────────────────┘*/
    set(target = 0, col = []) {
    // Обнуляем содержимое таблицы
        delete this.content;
        
    // Обновляем текущий столбец
        this.cols.splice(target < this.cols.length ? target : -1, 1, col);
    }
    
/*┌───────────────────────────────────────────┐
  │ Добавляет новый столбец в список столбцов │
  └───────────────────────────────────────────┘*/
    add(target = 0, col = []) {
    // Обнуляем содержимое таблицы
        delete this.content;
        
    // Индекс целевого столбца меньше нуля
        target = target == -1 ? this.cols.length : target < 0 ? target+1 : target;
        
    // Добавляем новый столбец
        this.cols.splice(target, 0, col);
    }
    
/*┌─────────────────────────────────────────────────────────────────┐
  │ Обновляет текущий или добавляет новый столбец в списке столбцов │
  └─────────────────────────────────────────────────────────────────┘*/
    save(target = 0, col = []) {
    // Проверяем существует-ли целевой столбец
        if (this.isCol(target)) {
        // Обновляем текущий целевой столбец
            this.set(target, col);
        }
        
    // Целевого столбца еще не существует
        else {
        // Создаем новый целевой столбец
            this.add(target, col);
        }
    }
    
/*┌───────────────────────────────────────────────────┐
  │ Проверяет существует-ли столбец в списке столбцов │
  └───────────────────────────────────────────────────┘*/
    isCol(index = 0) {
        return this.cols.length > index ? true : false;
    }
    
/*┌─────────────────────────────────────┐
  │ Получает столбец из списка столбцов │
  └─────────────────────────────────────┘*/
    col(index = 0) {
        return this.cols.slice(index < this.cols.length ? index : -1)[0]||[];
    }
    
/*┌──────────────────────────────────────────────────┐
  │ Получает общую сумму всех чисел текущего столбца │
  └──────────────────────────────────────────────────┘*/
    total(index = 0) {
        return this.col(index).reduce((total, number) => {
            return total + (Number(number)||0);
        }, 0);
    }
    
/*┌────────────────────────────────────────────────┐
  │ Проверяет содержит-ли текущий столбец проценты │
  └────────────────────────────────────────────────┘*/
    isPercents(index = 0) {
    // Получаем общую сумму всех чисел
        let total = this.total(index);
        
    // Проверяем содержит-ли текущий столбец проценты
        return total >= 99 && total <= 101;
    }
    
/*┌────────────────────────────────────┐
  │ Создает новый столбец с процентами │
  └────────────────────────────────────┘*/
    toPercents(numbers = [], digits = 1) {
    // Переводим в число
        numbers = numbers.map(number => Number(number)||0);
        
    // Получаем сумму всех чисел
        let total = numbers.reduce((total, number) => {
            return total + number;
        }, 0);
        
    // Возвращаем список с процентами
        return numbers.map((number) => {
        // Получаем процент
            return parseFloat(number * 100 / total).toFixed(digits);
        });
    }
    
/*┌────────────────────────────────────────────────┐
  │ Добавляет проценты в новый или текущий столбец │
  └────────────────────────────────────────────────┘*/
    percents(source = -1, target = 0) {
    // Проверяем присутствуют-ли цифры в столбце источнике
        if (this.total(source) != 0) {
        // Проверяем существует-ли целевой столбец
            if (this.isPercents(target)) {
            // Обновляем текущий целевой столбец
                this.set(target, this.toPercents(this.col(source)));
            }
            
        // Целевого столбца еще не существует
            else {
            // Создаем новый целевой столбец
                this.add(target, this.toPercents(this.col(source)));
            }
        }
    }
}

/*────────────────────────────────────────────────────────────────────────────────────────────────*/

class MOEX {
// Валютный тикер
    static currency = 'RUBB';
    
// Список тикеров с минимально возможным количеством для совершения покупки
    static minBuy = {
        'SBER': 10,
        'MOEX': 10,
        'MTSS': 10,
        'IRAO': 100
    };
    
// Список цен тикеров
    static prices = {};
    
/*┌────────────────────────┐
  │ Возвращает цену тикера │
  └────────────────────────┘*/
    static price(ticker = '') {
        return Number(this.prices[ticker] || 0);
    }
    
/*┌───────────────────────────────────────────────────────────────────┐
  │ Возвращает минимально возможное количество для совершения покупки │
  └───────────────────────────────────────────────────────────────────┘*/
    static minCount(ticker = '') {
        return this.minBuy[ticker] || 1;
    }
    
/*┌──────────────────────────────────────────────┐
  │ Проверяет является-ли тикер валютным тикером │
  └──────────────────────────────────────────────┘*/
    static isCurrency(ticker = '') {
        return ticker == this.currency;
    }
    
/*┌─────────────────────────────────┐
  │ Создает предложение для покупки │
  └─────────────────────────────────┘*/
    static offer(tickers = [], costs = [], prices = [], offers = [], currency = -1) {
    // Проходим по списку предложений
        while (true) {
        // Валютный тикер не найден
            if (currency == -1) break;
            
        // Создаем номер тикера с наименьшей общей стоимостью
            let ticker = -1;
            
        // Проходим по списку тикеров с текущей стоимостью
            costs.reduce((min, cost, i) => {
            // Проверяем является-ли тикер валютным тикером
                if (currency == i) return min;
                
            // Цена тикера меньше одного
                if (prices[i] < 1) return min;
                
            // Цена тикера больше текущего баланса
                if (prices[i] > costs[currency]) return min;
                
            // Тикер не является тикером с наименьшей общей стоимостью
                if (cost > min) return min;
                
            // Получаем номер тикера с наименьшей общей стоимостью
                ticker = i;
                
            // Возвращаем наименьшую общую стоимость
                return cost;
            }, Infinity);
            
        // На текущем балансе недостаточно средств
            if (ticker == -1) break;
            
        // На текущем балансе недостаточно средств
            if (prices[ticker] > costs[currency]) break;
            
        // Прибавляем текущую цену к общей стоимости
            costs[ticker] += prices[ticker];
            
        // Прибавляем текущую цену к общей стоимости
            offers[ticker] += this.minCount(tickers[ticker]);
            
        // Вычитаем текущую цену из баланса
            costs[currency] -= prices[ticker];
        }
        
    // Переводим в строку
        costs = costs.map(cost => String(cost));
        
    // Переводим в строку и добавляем плюс
        offers = offers.map(offer => offer > 0 ? ['+', offer].join('') : '');
        
    // Возвращаем предложение для покупки
        return {
            costs: costs,   // Столбец с текущей стоимостью
            offers: offers, // Столбец с дополнительным количеством
        };
    }
    
/*┌─────────────────────────────────┐
  │ Создает ребалансировку портфеля │
  └─────────────────────────────────┘*/
    static rebalance(tickers = [], counts = []) {
    // Создаем список с текущей стоимостью
        let costs = tickers.map((ticker, i) => {
            return parseInt(this.price(ticker) * counts[i]||0);
        });
        
    // Создаем список с минимально возможной ценой
        let prices = tickers.map((ticker, i) => {
            return parseInt(this.price(ticker) * this.minCount(ticker));
        });
        
    // Создаем список с дополнительным количеством
        let offers = Array(counts.length).fill(0);
        
    // Создаем номер валютного тикера
        let currency = tickers.findIndex(ticker => this.isCurrency(ticker));
        
    // Создаем предложение для покупки
        return this.offer(tickers, costs, prices, offers, currency);
    }
}
MOEX.prices = {
    'LKOH': 6837.5,
    'SBER': 230.39,
    'NVTK': 808,
    'PHOR': 5443,
    'MGNT': 4477.5,
    'MOEX': 178.8,
    'MTSS': 168.7,
    'IRAO': 3.6185,
    'GCHE': 4267,
    'RUBB': 1
};

/*────────────────────────────────────────────────────────────────────────────────────────────────*/

(() => {
// Создаем контент для таблицы
    let content;
    content = [
        'LKOH    3',
        'SBER   70',
        'NVTK    7',
        'PHOR    2',
        'MGNT    4',
        '',
        'MOEX   40',
        'MTSS   90',
        'IRAO 1700',
        'GCHE    0',
        'RUBB  350'
    ].join('\n');
    content = [
        'f        1                 ',
        'LKOH     3 20718 20.5      ',
        'SBER    70 16382 16.3      ',
        'NVTK     1  5672  5.6    +7',
        'PHOR     1 11084 11.0    +2',
        'MGNT     4 18098 18.0      ',
        '  ',
        'MOEX     1  7219  7.2   +40',
        'MTSS    90 15246 15.2      ',
        'IRAO     1  6168  6.1 +1700',
        'GCHE     0     0  0.0      ',
        'RUBB   307   164  0.2      '
    ].join('\n');
    
// Создаем новую таблицу
    table = new Table(
    // Устанавливаем пределы таблицы (диапазон принимаемых столбцов)
        ~2, // От начала до второго столбца (то есть первый и второй столбцы)
        
    // Устанавливаем начальный контент
        content,
        
    // Устанавливаем флаг сохранять пустые ряды
        true
    )
    
// Пример прерывания дальнейшего внесения изменений в таблицу
    .edit(function() {
        if (0) this.break;
    })
    
// Создаем ребалансировку портфеля
    .edit(function(colTickers, colCounts, colCosts, colPercents, colOffers) {
    // Создаем ребалансировку портфеля
        let {
            costs, // Список с текущей стоимостью
            offers // Список с дополнительным количеством
        } = MOEX.rebalance(this.col(colTickers), this.col(colCounts));
        
    // Добавляем столбец с текущей стоимостью
        this.save(colCosts, costs);
        
    // Добавляем столбец с процентами
        this.percents(colCosts, colPercents);
        
    // Добавляем столбец с дополнительным количеством
        if (offers.filter(offer => offer !== '').length > 0) {
            this.save(colOffers, offers);
        }
        
    // Возвращаем результат
        _=this.value
    }, ~5);
})();

/*────────────────────────────────────────────────────────────────────────────────────────────────*/